
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Primer Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    
    <link rel="prev" href="introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="introduction.html">
            
                <a href="introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2" data-path="primer.html">
            
                <a href="primer.html">
            
                    
                    Primer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./">
            
                    
                    Getting Started
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="environment.html">
            
                <a href="environment.html">
            
                    
                    Environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="project-structure.html">
            
                <a href="project-structure.html">
            
                    
                    Project Structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="build.html">
            
                <a href="build.html">
            
                    
                    Build
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="hello-world.html">
            
                <a href="hello-world.html">
            
                    
                    Hello World
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Primer</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="primer">Primer</h1>
<hr>
<p>This is by no means a comprehensive introduction to JavaScript. The goal of this document is to serve as a reference guide that will be used throughout this book and pertains to JavaScript as it relates to web browsers. Topics specific to other JavaScript runtime environments, such as node, are not covered.</p>
<p>It is not important for one to fully comprehend this guide before starting this book. Topics in this guide will be referenced and elaborated on throughout this book. Feel free to skip the primer for now or read it in its entirety, the choice is yours.</p>
<h2 id="comments">Comments</h2>
<hr>
<p>Single line comments come after <code>// comment</code> while multiline comments are achieved with <code>/* comment */</code></p>
<pre><code class="lang-js"><span class="hljs-comment">// One line comment</span>

<span class="hljs-comment">/* A longer comment,
spanning multiple lines.
*/</span>
</code></pre>
<h2 id="declarations">Declarations</h2>
<hr>
<pre><code class="lang-js"><span class="hljs-comment">/*
* Declaring variables.
*/</span>

<span class="hljs-comment">// without initializing a value</span>
<span class="hljs-keyword">var</span> name;
<span class="hljs-comment">// Declaring and initializing a variable</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">121</span>;

<span class="hljs-comment">// Let and Const.</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">super</span> = <span class="hljs-string">&quot;secret&quot;</span>;
<span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;
</code></pre>
<p><code>let</code> and <code>const</code> are relatively new additions to the JavaScript language. <code>var</code>, on the other hand, has been with JS since the beginning. <code>const</code> is easy to understand. As one might guess, <code>const</code> declares a constant value that will not, and cannot, change. To fully understand the difference between <code>var</code> and <code>let</code> one must first understand scope, a topic covered later in this guide.</p>
<blockquote>
<p><strong>Initialize</strong>. To set a variable equal to a starting value at the time the variable is declared, e.g., <code>var name = &quot;Derek&quot;;</code>. </p>
</blockquote>
<h2 id="data-types">Data Types</h2>
<hr>
<p>Values in JavaScript take on a type, such as <code>string</code> or <code>number</code>. To truly understand the type system it is important for one to understand the object-oriented nature of JavaScript.</p>
<p>JavaScript is a multi-paradigm language. A fancy way of saying that JavaScript supports multiple ways, or styles, of programming. <strong>Object-oriented programming (OOP)</strong> is one such paradigm. This is to say that all data types, except <code>null</code> and <code>undefined</code>, act as objects. An <strong>object</strong> is a collection of data (<strong>properties</strong>) and functionality (<strong>methods</strong>). Properties and methods of an object are accessed through dot notation.</p>
<pre><code class="lang-js"><span class="hljs-comment">// string value</span>
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">&quot;hello world!&quot;</span>;

<span class="hljs-comment">// accessing the string length property</span>
myString.length

<span class="hljs-comment">// Accessing the string toUpperCase method</span>
myString.toUpperCase();
<span class="hljs-comment">// =&gt; &quot;HELLO WORLD!&quot;;</span>

<span class="hljs-comment">// Can even call methods off the direct value</span>
<span class="hljs-string">&quot;hello world&quot;</span>.toUpperCase();
</code></pre>
<p>As shown above, properties and methods are accessed using dot notation, i.e., <code>Object.property</code> or <code>Object.method()</code>. We may also declare custom objects using <code>{ ... }</code>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// this object contains only properties</span>
<span class="hljs-keyword">var</span> data = {
    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Derek&quot;</span>,
    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">100</span>
};

data.name;
<span class="hljs-comment">// =&gt; &quot;Derek&quot;</span>

<span class="hljs-comment">// this object contains methods</span>
<span class="hljs-keyword">var</span> car = {
    <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;red&quot;</span>,
    <span class="hljs-string">&quot;reverse&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// reverse...</span>
    }
}

car.reverse();
<span class="hljs-comment">// =&gt; ... reverses the car.</span>
</code></pre>
<p>Objects are represented as a collections of keys, which are strings, and corresponding values, which can be of any type. If the value is a function then it is considered a method. Otherwise the value is a property. In the above example, <code>car.color</code> is a property while <code>car.reverse</code> is a method.</p>
<p>There are currently 7 data types in JavaScript which can be grouped into two categories, primitives and Object.</p>
<h3 id="primitives">Primitives</h3>
<ol>
<li>null. the null type has one value, <code>null</code>, which represents the absence of a value. <pre><code class="lang-js"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;
</code></pre>
</li>
<li><p>undefined. Like null, the undefined type has one value, <code>undefined</code>, is is assigned to variables that have not been assigned a value.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> name;
<span class="hljs-built_in">console</span>.log(name);
<span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
</li>
<li><p>Boolean: <code>true</code> and <code>false</code></p>
</li>
<li>Number. Either an integer or a floating point, e.g., <code>100</code> or <code>3.14159</code></li>
<li>String. A sequence of characters wrapped in single or double quotes, e.g., <code>&quot;Hello World&quot;</code></li>
<li>Symbol. A new type in the latest version of JavaScript. We will not cover symbols for now.</li>
</ol>
<h3 id="objects">Objects</h3>
<p>Functions and arrays are two examples of objects that are not considered primitives.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Function declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + name);

<span class="hljs-comment">// Functions can also be declared as variables</span>
<span class="hljs-comment">// This is known as a function expression</span>
<span class="hljs-comment">// this returns a function handler that is stored in </span>
<span class="hljs-comment">// sayHello variable.</span>
<span class="hljs-keyword">var</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + name);
}

sayHello(<span class="hljs-string">&quot;Derek&quot;</span>);
<span class="hljs-comment">// =&gt; &quot;Hello, Derek&quot;</span>

<span class="hljs-comment">// An array, a collection of items</span>
<span class="hljs-keyword">var</span> myList = [<span class="hljs-string">&quot;Derek&quot;</span>, <span class="hljs-string">&quot;Kris&quot;</span>, <span class="hljs-number">100</span>];
</code></pre>
<p>To reiterate, an object is a data type that contains properties and methods and supports dot notation for accessing said properties and methods. Yes, even functions support dot notation. A function is a regular object with the additional property of being callable. Remember, everything (except <code>null</code> and <code>undefined</code>) in JavaScript acts as an object, hence the object-oriented nature of JS. </p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// do something</span>
}

<span class="hljs-comment">// Accessing the name property of a function</span>
sayHello.name <span class="hljs-comment">// =&gt; &quot;sayHello&quot;</span>

<span class="hljs-comment">// Calling the function</span>
sayHello();
</code></pre>
<p>Earlier it was stated that all data types, except <code>null</code> and <code>undefined</code>, <strong>act</strong> as objects. So then what is a primitive? A primitive data type is one that is not an object, i.e., has no properties or methods and thus does not support dot notation. But earlier we saw an example of calling <code>toUpperCase</code> off the so called string primitive using dot notation, e.g., <code>&quot;Hello World&quot;.toUpperCase()</code>.</p>
<p>What gives? If primitives, such as strings, are not objects and do not have methods then how can we call <code>toUpperCase</code> on a string primitive? Well, it turns out that all primitive types, except <code>null</code> and <code>undefined</code>, have object equivalents that provide additional properties and methods.</p>
<p>For example, <code>string</code> literals have an equivalent <code>String</code> object type. The <code>String</code> object type can be declared using the <code>String</code> function. The <code>String</code> function is an example of a <strong>constructor</strong>, a function used to construct an object type, in this case, a <code>String</code> object type.   </p>
<blockquote>
<p><strong>Note</strong> It is common to capitalize the first letter of a constructor. The name of a constructor function also serves as the name of the object type it creates. In essence, <code>String</code> refers to a constructor and the object type it creates while <code>string</code> refers to the primitive type.</p>
</blockquote>
<pre><code class="lang-js"><span class="hljs-comment">// string literal</span>
<span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;Derek&quot;</span>;

<span class="hljs-comment">// String object</span>
<span class="hljs-keyword">var</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;Derek&quot;</span>);

<span class="hljs-comment">// str1 is, in fact, a string</span>
<span class="hljs-built_in">console</span>.log(str1); 
<span class="hljs-comment">// =&gt; &quot;Derek&quot;</span>

<span class="hljs-comment">// str2 is not a string.</span>
<span class="hljs-comment">// Instead it is an object that wraps the original string value.</span>
<span class="hljs-built_in">console</span>.log(str2); 
<span class="hljs-comment">// =&gt; something like String {&quot;Derek&quot;} or [String, &quot;Derek&quot;] depending on browser</span>

<span class="hljs-comment">// valueOf will return the literal value wrapped by the object type</span>
<span class="hljs-built_in">console</span>.log(str2.valueOf()); <span class="hljs-comment">// =&gt; &quot;Derek&quot;</span>

<span class="hljs-comment">// The two types are not the same</span>
str1 === str2 <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// but the values are.</span>
str1 === str2.valueOf() <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>In JavaScript land, primitives are automatically converted to corresponding object types, providing properties and methods related to that type. This auto-conversion is what allows for such madness as <code>&quot;hello world&quot;.toUpperCase()</code>, a primitive accessing a method using dot notation.</p>
<p>In the introductory paragraph for this section I was careful to state that all data types, except <code>null</code> and <code>undefined</code>, <strong>act</strong> as objects, as opposed to saying all data types <strong>are</strong> objects. This distinction, though accurate, is not too important. The important takeaway is that all data types, except <code>null</code> and <code>undefined</code>, act as objects. This is to say that all data types support dot notation for accessing additional properties and methods. Even so called primitives, through JavaScript&apos;s auto-conversion, act as objects and support dot notation. Just remember, <code>null</code> and <code>undefined</code> are special.</p>
<h3 id="literals">Literals</h3>
<p>To define a data type without using a constructor function is to create a literal value of that type. For example, string literals can be created using single or double quotes. Both primitives and object types can be declared as literals.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Primitives declared as literals</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Derek&quot;</span>;
<span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;
<span class="hljs-keyword">var</span> something = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">var</span> nothing = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> isOldEnough = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// object and array literals</span>
<span class="hljs-keyword">var</span> myObj = {
    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Derek&quot;</span>
}
<span class="hljs-keyword">var</span> myList = [<span class="hljs-string">&quot;Derek&quot;</span>, <span class="hljs-string">&quot;Kris&quot;</span>, <span class="hljs-number">100</span>];
</code></pre>
<p>As shown earlier with <code>String</code>, constructor functions may be used to create objects instead of creating them as literals. </p>
<pre><code class="lang-js"><span class="hljs-comment">// Using constructor functions</span>
<span class="hljs-comment">// Primitives</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;Derek&quot;</span>);
<span class="hljs-keyword">var</span> age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">28</span>);
<span class="hljs-keyword">var</span> isOldEnough = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>); 

<span class="hljs-comment">/* null and undefined do not act as objects
and do not have constructors to create object equivalents. 
*/</span>

<span class="hljs-comment">// objects and array constructors</span>
<span class="hljs-keyword">var</span> myObh = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>({
    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Derek&quot;</span>
});
<span class="hljs-keyword">var</span> myList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&quot;Derek&quot;</span>, <span class="hljs-string">&quot;Kris&quot;</span>, <span class="hljs-number">100</span>);
</code></pre>
<p>In practice, constructors for primitive types, plain objects and arrays are rarely used. Instead, values of these types are almost always declared as literals. Constructors tend to be used to <strong>instantiate</strong> custom object types. This will be explored later on.</p>
<blockquote>
<p><strong>Instantiate</strong> To create an instance of an Object type. <code>new String(&quot;Hello&quot;);</code> is creating, or instantiating, a new instance of the <code>String</code> type. </p>
</blockquote>
<h3 id="comparing-values">Comparing Values</h3>
<p>JavaScript provides multiple ways to compare and contrast values.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;Derek&quot;</span>;
<span class="hljs-keyword">var</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;Derek&quot;</span>);

<span class="hljs-comment">// == for comparing values</span>
str1 == str2 <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// === for comparing values and types</span>
str1 === str2 <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// != for contrasting values</span>
str1 != str2 <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// !== for contrasting values and types</span>
str1 !== str2 <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p><code>==</code> and <code>!=</code> compare by value only. This is to say that JavaScript ignores the types of the values when comparing with <code>==</code> and <code>!=</code>. In order to compare values of different types, JavaScript will first convert the values to the same type before comparing. This is why <code>str1 == str2</code> returns <code>true</code> and <code>str1 != str2</code> returns <code>false</code>. Once both operands (both sides of the comparison) are of the same type they contain the same value of <code>&quot;Derek&quot;</code>. However, <code>str1</code> and <code>str2</code> are not of the same type. The former is a <code>string</code> primitive while the latter is a <code>String</code> object. This is where <code>===</code> and <code>!==</code> come into play. Both methods compare by type and value. <code>===</code> checks that the operands are equal in value and in type while <code>!==</code> checks that the operands are either not equal in value or not equal in type.  </p>
<p>Constructors are not often used to create object representations of primitives. Here is a more realistic example of JavaScript coercing a value from one type to another that may pop up in practice.</p>
<pre><code class="lang-js"><span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-string">&quot;1&quot;</span> === <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-string">&quot;true&quot;</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-string">&quot;true&quot;</span> === <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-string">&quot;1&quot;</span> != <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-string">&quot;1&quot;</span> !== <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-string">&quot;true&quot;</span> != <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-string">&quot;true&quot;</span> !== <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>JavaScript <del>can</del> will do some strange things when coercing a value from one type to another. For this reason, it is recommended that <code>===</code> and <code>!==</code> are used to ensure that values are of the same type when comparing. </p>
<h2 id="variable-scope">Variable Scope</h2>
<hr>
<p>&quot;There is no scope but function scope&quot;. This use to be a popular statement when talking about JS. The meaning is simple, variables defined outside of any function are global while variables defined within a function are local to that function and cannot be accessed by the outside world. This statement, though true for variables declared with <code>var</code>, is not true for values created with <code>let</code> and <code>const</code>. For now, lets examine how function scoping works with values created with <code>var</code>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Global variable</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">127</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAge</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// this age variable is local to logAge</span>
    <span class="hljs-comment">// and overrides the global age variable</span>
    <span class="hljs-comment">// within logAge since they share the same name</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">23</span>;
    <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 23</span>
}

<span class="hljs-comment">// The age variable local to logAge</span>
<span class="hljs-comment">// had no impact on the global age variable</span>
<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 127</span>
<span class="hljs-comment">// Global variables are also accessible from the window object. </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.age);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// name variable local to printName</span>
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Derek&quot;</span>;
    <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// =&gt; Derek</span>
}

<span class="hljs-comment">// There is no global name variable</span>
<span class="hljs-comment">// and the name variable within printName</span>
<span class="hljs-comment">// is no longer in scope and thus not accessible</span>
<span class="hljs-built_in">console</span>.log(name);
<span class="hljs-comment">// uncaught referenceError. name is not defined.</span>
</code></pre>
<p>Here is another example showing that once again &quot;there is no scope but function scope&quot;, at least when it comes to <code>var</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Still a global variable </span>
    <span class="hljs-comment">// and accessible from outside the conditional block</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">25</span>;
}
<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 25</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAge</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// still local to logAge</span>
        <span class="hljs-comment">// and accessible to the rest of logAge</span>
        <span class="hljs-keyword">var</span> age = <span class="hljs-number">35</span>;
    }
    <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 35</span>
}
</code></pre>
<p>Global variables, once defined, are accessible from anywhere using the global object, <code>window</code>, even from other files, hence global.</p>
<h3 id="block-scope">Block Scope</h3>
<p>Unlike <code>var</code>, <code>let</code> and <code>const</code> declare block level variables. Variables created with <code>let</code> and <code>const</code> are scoped to a single block of code (code between a matching pair of <code>{</code> and <code>}</code>). Sadly, &quot;there is no scope but function scope&quot; is no longer a global truth when talking about JS as both <code>let</code> and <code>const</code> allow one to create block level variables instead of function level variables (statement is still valid when talking about values created with <code>var</code>).</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAgeWithLet</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// age is scoped to the surrounding conditional block, instead of the surrounding function, </span>
        <span class="hljs-comment">// and is thus not accessible outside of the conditional block</span>
        <span class="hljs-keyword">let</span> age = <span class="hljs-number">28</span>;
        <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 28</span>
    }
    <span class="hljs-built_in">console</span>.log(age);
    <span class="hljs-comment">// Uncaught ReferenceError: age is not defined.</span>
}
</code></pre>
<h3 id="hoisting">Hoisting</h3>
<p>What happens when one tries to access a variable that was not defined? Let&apos;s see</p>
<pre><code class="lang-js"><span class="hljs-built_in">console</span>.log(someVariable);
<span class="hljs-comment">// =&gt; Uncaught ReferenceError: someVariable is not defined</span>
</code></pre>
<p>As opposed to defining variable without initializing it to a value.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> age;
<span class="hljs-built_in">console</span>.log(age);
<span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>So one might expect a &quot;not defined&quot; reference error with the following code since <code>age</code> is being accessed before it is defined.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(age);
    <span class="hljs-comment">// expect an uncaught ReferenceError.</span>

    <span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;
}

doSomething();
<span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>In reality, it results in an <code>undefined</code> instead of a reference error. That is because the above code is evaluated as the following when interpreted by the JavaScript runtime environment. </p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// the age declaration is hoisted to the top of the defining function scope</span>
    <span class="hljs-keyword">var</span> age;
    <span class="hljs-built_in">console</span>.log(age);

    age = <span class="hljs-number">28</span>;
}
</code></pre>
<p>This is known as <strong>hoisting</strong>, to lift variable declarations to the top of the defining scope. Again, <code>var</code> declarations are function scoped so hoisting means to lift variable declarations to the top of the containing function definition. Only declarations are hoisted, initialization, as shown above, occur at the original location.</p>
<p>Hoisting does not apply to <code>let</code> or <code>const</code> so the following code will result in a &quot;not defined&quot; reference error.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(age);
    <span class="hljs-comment">// =&gt; Uncaught ReferenceError: age is not defined</span>

    <span class="hljs-keyword">let</span> age = <span class="hljs-number">28</span>;
}
</code></pre>
<h2 id="modules">Modules</h2>
<hr>
<p>Since any variable declared outside of a function is global, it is common to wrap all code within a function declaration, to avoid polluting the global namespace. The wrapping function may return an object containing properties and methods for consumers to work with, if needed. This is known as the module pattern and is a common design pattern for JavaScript libraries, including the popular jQuery library.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Self-invoking anonymous function.</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// age scoped to the surrounding function, thus not polluting the </span>
    <span class="hljs-comment">// global namespace.</span>
    <span class="hljs-comment">// age is only accessible from within the defining anonymous function, aka module,</span>
    <span class="hljs-comment">// thus age is said to be private to this module.</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// some code</span>

        <span class="hljs-comment">// doSomething has access to the surrounding scope and thus has access to age.</span>
        <span class="hljs-built_in">console</span>.log(age);
    }

    <span class="hljs-comment">// This module does not return any properties or functions</span>
    <span class="hljs-comment">// for consumers of the library to work with.</span>
    <span class="hljs-comment">// Instead, the module executes doSomething as soon as </span>
    <span class="hljs-comment">// it is loaded.</span>
    doSomething();
})();
</code></pre>
<pre><code class="lang-js"><span class="hljs-comment">// self-invoking anonymous function</span>
<span class="hljs-keyword">var</span> libraryGlobal = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Private to this module</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// do something</span>

        <span class="hljs-built_in">console</span>.log(age);
    }

    <span class="hljs-comment">// This module returns functionality for consumers</span>
    <span class="hljs-comment">// to interact with.</span>
    <span class="hljs-comment">// return doSomething to be executed at a later time.</span>
    <span class="hljs-keyword">return</span> {
        doSomething: doSomething
    };
})();

<span class="hljs-comment">// Using the library elsewhere</span>
libraryGlobal.doSomething();
</code></pre>
<p>Both examples demonstrate the module pattern. The first executes functionality, <code>doSomething</code>, when loaded while the second example exposes the same functionality off the <code>libraryGlobal</code> variable to be executed at a later time.</p>
<p>Both examples make use of self-invoking (or self-executing) anonymous functions to encapsulate the functionality of the module and, if necessary, expose properties and methods off a single global variable (the second example).</p>
<blockquote>
<p><strong>Anonymous functions</strong> are unnamed functions, e.g., <code>function() { ... }</code>, as opposed to <code>function sayHello() { ... }</code> which is a named function.</p>
<p><strong>Self-invoking functions</strong> are functions that execute immediately after being defined. This can be achieved by wrapping the function definition in <code>()</code> followed by an additional <code>()</code> to call the function, e.g., <code>(function sayHello() { ... })();</code>. Note that both named and anonymous functions can self invoke.</p>
</blockquote>
<h2 id="closures">Closures</h2>
<hr>
<blockquote>
<p>A <strong>closure</strong> is a function bounded to the environment, or scope, in which it was declared. </p>
</blockquote>
<p>The last section showed an example of a closure. The module pattern in the second example returned a function that had access to variables defined within the same scope. <code>libraryGlobal.doSomething</code> is a closure, as it is a function that has access to <code>age</code>, a variable not declared within <code>doSomething</code> but within the same scope <code>doSomething</code> was declared. <code>doSomething</code> is a function that is bounded to its defining scope, the self-invoking anonymous function.</p>
<p>Recall that there is no scope but function scope. Hence, functions create closures, which, again, are functions bounded to the surrounding scope. Simply stated, a closure is when a function creates scope for another function to use at a later time. Here is another example of a closure.</p>
<pre><code class="lang-js"><span class="hljs-comment">// 1. First function creating scope...</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAgeRestriction</span>(<span class="hljs-params">minimumAgeLimit</span>) </span>{

    <span class="hljs-comment">// 2. ...to be used by another function at a later time.</span>
    <span class="hljs-comment">// checkAgeRestriction will always have access to minimumAgeLimit</span>
    <span class="hljs-comment">// defined within the surrounding scope </span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAgeRestriction</span>(<span class="hljs-params">age</span>) </span>{
        <span class="hljs-keyword">if</span>(age &gt; minimumAgeLimit) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;you may enter&apos;</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(age + <span class="hljs-string">&apos; does not meet the age requirement&apos;</span>);
        }
    }
    <span class="hljs-keyword">return</span> checkAgeRestriction;
}

<span class="hljs-comment">// canDrink is a clusure</span>
<span class="hljs-keyword">var</span> canDrink = setAgeRestriction(<span class="hljs-number">21</span>);

<span class="hljs-comment">// canDrink will have access to the </span>
<span class="hljs-comment">// minimumAgeLimit, which is set to 21,</span>
<span class="hljs-comment">// for as long as it needs it and can be called </span>
<span class="hljs-comment">// many times with different ages to compare </span>
<span class="hljs-comment">// against the minimumAgeLmit</span>
canDrink(<span class="hljs-number">44</span>); <span class="hljs-comment">// =&gt; &quot;you may enter&quot;</span>

<span class="hljs-comment">// much later on...</span>
canDrink(<span class="hljs-number">19</span>); <span class="hljs-comment">// =&gt; &quot;19 does not meet the age requirement&quot;</span>
</code></pre>
<h2 id="this">This</h2>
<hr>
<p>In object-oriented languages, <code>this</code> is commonly used as a reserved keyword, one that references an object. In JavaScript, <code>this</code> references the calling object. </p>
<p>Examples best clarify the <code>this</code> keyword and its intended meaning.</p>
<pre><code class="lang-js"><span class="hljs-comment">// global variable accessible off the window object.</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;

<span class="hljs-keyword">var</span> person = {
    age: <span class="hljs-number">20</span>,
    getAge: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// this refers to the object</span>
        <span class="hljs-comment">// that ends up calling getAge</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age);
    }
}

<span class="hljs-comment">// person calls getAge using dot notation</span>
person.getAge();
<span class="hljs-comment">// =&gt; 20</span>
</code></pre>
<p>Calling <code>person.getAge()</code> prints <code>20</code> to the browser console, as one might expect. However, <code>10</code> will be printed out in the following example using the same <code>getAge</code> function. Lets see if we can determine why that is the case.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> newGetAge = person.getAge;

<span class="hljs-comment">// What object is calling newGateAge?</span>
newGetAge();
<span class="hljs-comment">// =&gt; 10.</span>
</code></pre>
<p>In this example, the <code>getAge</code> function handler is stored in the <code>newGetAge</code> global variable. When a function is called directly (without dot notation) it is implicitly called by the global object, <code>window</code>. This is to say that <code>newGetAge</code> is called by <code>window</code> and is equivalent to <code>window.newGetAge()</code>. In this case, <code>10</code> is printed to the browser console since <code>window.age = 10</code>, as declared in the first code snippet. </p>
<blockquote>
<p><strong>this</strong> refers to the calling object. The topic of <strong>this</strong> will be covered thoroughly throughout this book</p>
</blockquote>
<p><code>this</code> can cause all sorts of bugs and undesirable results when functions are called by unexpected objects. Calling a function from an unexpected object may sound farfetched but its not, it happens all the time. Problems that result from calling functions from unexpecting objects will be covered throughout this book.</p>
<h3 id="bind">bind</h3>
<p>The <code>Function</code> object provides a method to prevent <code>this</code> from referencing an unexpected object, <code>bind</code>. Let&apos;s rewrite the above example using <code>bind</code> to see how it behaves.</p>
<pre><code class="lang-js"><span class="hljs-comment">// global variable accessible off the window object.</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>; 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalGetAge</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age);
}

<span class="hljs-keyword">var</span> person = {
    age: <span class="hljs-number">20</span>
};

<span class="hljs-comment">// this time, declare person.getAage as a bounded</span>
<span class="hljs-comment">// version of globalGetAage in which this will always be bounded </span>
<span class="hljs-comment">// to person</span>
person.getAge = globalGetAge.bind(person);

person.getAge(); <span class="hljs-comment">// =&gt; 20;</span>

<span class="hljs-keyword">var</span> newGetAge = person.getAge;

newGetAge(); 
<span class="hljs-comment">// =&gt; 20</span>
</code></pre>
<p><code>bind</code> will bind a function handler to a specific calling object (<code>this</code>) for all future calls. <code>bind</code> accepts multiple arguments, the first being the objet that will bind to <code>this</code> within the provided function handler. </p>
<p><code>globalGetAge.bind(person)</code> returns a copy of <code>globalGetAge</code> in which <code>this</code> is bounded to <code>person</code>, regardless of which object eventually calls <code>person.getAge</code>. This time, <code>20</code> is pritned when <code>newGetAge</code> is called since the function handler represented by <code>person.getAge</code>, which is stored in <code>newGetAge</code>, is bounded to person. It does not matter that <code>newGetAge</code> is called by <code>window</code> instead of <code>person</code>, the function handler itself is bounded to <code>person</code>.</p>
<blockquote>
<p><strong>Note</strong> <code>bind</code> returns a copy of the original function, that is bounded to the provided object, without modifying the original function. <code>globalGetAge</code> can still be called from different calling contexts and can be bounded to other objects, e.g., <code>var alwaysGlobalGetAge = globalGetAge.bind(window)</code>, <code>alwaysGlobalGetAge</code> will always print <code>10</code> when invoked since <code>window.age = 10</code>. </p>
</blockquote>
<p>Once bounded, a function cannot be rebounded.</p>
<pre><code class="lang-js"><span class="hljs-comment">// person.getAge is already a bounded function.</span>
<span class="hljs-comment">// this will not work</span>
<span class="hljs-keyword">var</span> rebindPersonGetAgeToWindow = person.getAge.bind(<span class="hljs-built_in">window</span>);

rebindPersonGetAgeToWindow();
<span class="hljs-comment">// does not print 10, which is what window.age is equal to.</span>
<span class="hljs-comment">// instead 20 is printed as rebindPersonGetAgeToWindow </span>
<span class="hljs-comment">// is still bounded to person</span>
</code></pre>
<h3 id="call-and-apply">Call and Apply</h3>
<p>The <code>Function</code> object provides two additional methods that can be used to change the calling context of a function, <code>call</code> and <code>apply</code>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="introduction.html" class="navigation navigation-prev " aria-label="Previous page: Introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="./" class="navigation navigation-next " aria-label="Next page: Getting Started">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Primer","level":"1.2","depth":1,"next":{"title":"Getting Started","level":"1.3","depth":1,"path":"README.md","ref":"README.md","articles":[{"title":"Environment","level":"1.3.1","depth":2,"path":"environment.md","ref":"environment.md","articles":[]},{"title":"Project Structure","level":"1.3.2","depth":2,"path":"project-structure.md","ref":"project-structure.md","articles":[]},{"title":"Build","level":"1.3.3","depth":2,"path":"build.md","ref":"build.md","articles":[]},{"title":"Hello World","level":"1.3.4","depth":2,"path":"hello-world.md","ref":"hello-world.md","articles":[]}]},"previous":{"title":"Introduction","level":"1.1","depth":1,"path":"introduction.md","ref":"introduction.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"primer.md","mtime":"2018-02-28T04:44:37.219Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-02-28T05:07:07.216Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

