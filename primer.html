
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Primer Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    
    <link rel="prev" href="introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="introduction.html">
            
                <a href="introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2" data-path="primer.html">
            
                <a href="primer.html">
            
                    
                    Primer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./">
            
                    
                    Getting Started
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="environment.html">
            
                <a href="environment.html">
            
                    
                    Environment
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="project-structure.html">
            
                <a href="project-structure.html">
            
                    
                    Project Structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="build.html">
            
                <a href="build.html">
            
                    
                    Build
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="hello-world.html">
            
                <a href="hello-world.html">
            
                    
                    Hello World
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Primer</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="primer"><a name="primer" class="plugin-anchor" href="#primer"><i class="fa fa-link" aria-hidden="true"></i></a>Primer</h1>
<hr>
<p>This is by no means a comprehensive introduction to JavaScript. The goal of this document is to serve as a reference guide that will be used throughout this book and pertains to JavaScript as it relates to web browsers. Topics specific to other JavaScript runtime environments, such as node, are not covered.</p>
<p>It is not important for one to fully comprehend this guide before starting this book. Topics in this guide will be referenced and elaborated on throughout this book. Feel free to skip the primer for now or read it in its entirety, the choice is yours.</p>
<h2 id="comments"><a name="comments" class="plugin-anchor" href="#comments"><i class="fa fa-link" aria-hidden="true"></i></a>Comments</h2>
<hr>
<p>Single line comments come after <code>// comment</code> while multiline comments are achieved with <code>/* comment */</code></p>
<pre><code class="lang-js"><span class="hljs-comment">// One line comment</span>

<span class="hljs-comment">/* A longer comment,
spanning multiple lines.
*/</span>
</code></pre>
<h2 id="declarations"><a name="declarations" class="plugin-anchor" href="#declarations"><i class="fa fa-link" aria-hidden="true"></i></a>Declarations</h2>
<hr>
<pre><code class="lang-js"><span class="hljs-comment">/*
* Declaring variables.
*/</span>

<span class="hljs-comment">// without initializing a value</span>
<span class="hljs-keyword">var</span> name;
<span class="hljs-comment">// Declaring and initializing a variable</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">121</span>;

<span class="hljs-comment">// Let and Const.</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">super</span> = <span class="hljs-string">&quot;secret&quot;</span>;
<span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;
</code></pre>
<ul>
<li><code>var</code> declares a function-scoped variable.</li>
<li><code>const</code> declares a block-scoped constant that will not change. </li>
<li><code>let</code> declares a block-scoped variable.</li>
</ul>
<p>See <a href="#variable-scope">variable scope</a> for more information. </p>
<blockquote>
<p><strong>Initialize</strong>. To set a variable equal to a starting value at the time the variable is declared, e.g., <code>var name = &quot;Derek&quot;;</code>. </p>
</blockquote>
<h2 id="data-types"><a name="data-types" class="plugin-anchor" href="#data-types"><i class="fa fa-link" aria-hidden="true"></i></a>Data Types</h2>
<hr>
<p>Values in JavaScript take on a type, such as <code>string</code> or <code>number</code>. To understand the type system it is important for one to understand the object-oriented nature of JavaScript.</p>
<p>JavaScript is a multi-paradigm language. A fancy way of saying that JavaScript supports multiple ways, or styles, of programming. <strong>Object-oriented programming (OOP)</strong> is one such paradigm. This is to say that all data types, except <code>null</code> and <code>undefined</code>, act as objects. </p>
<blockquote>
<p>An <strong>object</strong> is a collection of data (<strong>properties</strong>) and are represented as a set of <strong>keys</strong>, which are strings, and corresponding <strong>values</strong>, which can be of any type. A <strong>key-value</strong> pair is known as a <strong>property</strong>.</p>
</blockquote>
<pre><code class="lang-js"><span class="hljs-comment">// string value</span>
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">&quot;hello world!&quot;</span>;

<span class="hljs-comment">// using dot notation to access the length property of strings</span>
myString.length

<span class="hljs-comment">// dot notation for accessing toUpperCase method of strings</span>
myString.toUpperCase();
<span class="hljs-comment">// =&gt; &quot;HELLO WORLD!&quot;;</span>

<span class="hljs-comment">// Can even call methods off the literal value</span>
<span class="hljs-string">&quot;hello world&quot;</span>.toUpperCase();
</code></pre>
<p>As shown above, properties and methods are accessed using dot notation, i.e., <code>Object.property</code> or <code>Object.method()</code>. </p>
<p>One way to create an object is with  <code>{ ... }</code>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// this object contains only properties</span>
<span class="hljs-keyword">var</span> data = {
    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Derek&quot;</span>,
    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">100</span>
};

data.name;
<span class="hljs-comment">// =&gt; &quot;Derek&quot;</span>

<span class="hljs-comment">// this object contains methods</span>
<span class="hljs-keyword">var</span> car = {
    <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;red&quot;</span>,
    <span class="hljs-string">&quot;reverse&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// reverse...</span>
    }
}

car.reverse();
<span class="hljs-comment">// =&gt; ... reverses the car.</span>
</code></pre>
<blockquote>
<p>Properties that store functions are commonly referred to as <strong>methods</strong>. <code>car.reverse</code> is a method.</p>
</blockquote>
<p>There are currently 7 data types in JavaScript which can be grouped into two categories, primitives and object.</p>
<blockquote>
<p><strong>Primitive</strong>: a data type that is not an object, i.e., does not contain properties or methods and thus does not support dot notation.</p>
</blockquote>
<h3 id="primitives"><a name="primitives" class="plugin-anchor" href="#primitives"><i class="fa fa-link" aria-hidden="true"></i></a>Primitives</h3>
<ol>
<li>null. the null type has one value, <code>null</code>, which represents the absence of a value. <pre><code class="lang-js"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;
</code></pre>
</li>
<li>undefined. Like null, the undefined type has one value, <code>undefined</code>, is is assigned to variables that have not been assigned a value.<pre><code class="lang-js"><span class="hljs-keyword">var</span> name;
<span class="hljs-built_in">console</span>.log(name);
<span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
</li>
<li>Boolean: <code>true</code> and <code>false</code></li>
<li>Number. Either an integer or a floating point, e.g., <code>100</code> or <code>3.14159</code></li>
<li>String. A sequence of characters wrapped in single or double quotes, e.g., <code>&quot;Hello World&quot;</code></li>
<li>Symbol. A new type in the latest version of JavaScript. We will not cover symbols for now.</li>
</ol>
<h3 id="objects"><a name="objects" class="plugin-anchor" href="#objects"><i class="fa fa-link" aria-hidden="true"></i></a>Objects</h3>
<p>Functions and arrays are two examples of objects that are not considered primitives.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Function declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + firstName + <span class="hljs-string">&quot; &quot;</span> + lastName);
}

<span class="hljs-comment">// Functions can also be declared as variables</span>
<span class="hljs-comment">// This is known as a function expression</span>
<span class="hljs-comment">// this stores a function in </span>
<span class="hljs-comment">// the sayHello variable.</span>
<span class="hljs-keyword">var</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + firstName + <span class="hljs-string">&quot; &quot;</span> + lastName);
}

sayHello(<span class="hljs-string">&quot;Derek&quot;</span>);
<span class="hljs-comment">// =&gt; &quot;Hello, Derek&quot;</span>

<span class="hljs-comment">// An array, a collection of items</span>
<span class="hljs-keyword">var</span> myList = [<span class="hljs-string">&quot;Derek&quot;</span>, <span class="hljs-string">&quot;Kris&quot;</span>, <span class="hljs-number">100</span>];
</code></pre>
<blockquote>
<p>A <strong>function</strong> is a block of code that can be called by other code or by itself (<strong>self-invoking</strong>). Functions are invoked with parenthesis and a comma separated list of arguments, e.g., <code>sayHello(&quot;Derek&quot;, &quot;Worthen&quot;)</code>, and can optionally return output. <strong>Functions are objects</strong>, with the additional property of being callable, and thus support dot notation for accessing related properties and methods.  </p>
</blockquote>
<p>dot notation on a function: </p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// do something</span>
}

<span class="hljs-comment">// Accessing the name property of a function</span>
sayHello.name <span class="hljs-comment">// =&gt; &quot;sayHello&quot;</span>

<span class="hljs-comment">// Calling the function</span>
sayHello();
</code></pre>
<p>Primitives were defined as data types that do not support dot notation but earlier an example of calling <code>toUpperCase</code> off a string primitive using dot notation was shown, e.g., <code>&quot;Hello World&quot;.toUpperCase()</code>.</p>
<p>What gives? How can <code>toUpperCase</code> be called on a string primitive, a type that does not have methods and does not support dot notation? </p>
<p>Well, it turns out that all primitive types, except <code>null</code> and <code>undefined</code>, have object equivalents that provide additional properties and methods. For example, <code>string</code> literals have an equivalent <code>String</code>-object type. <code>String</code>-object types can be created using the <code>String</code> function. The <code>String</code> function is an example of a <strong>constructor</strong>, a function used to construct an object type, in this case, a <code>String</code>-object type.   </p>
<blockquote>
<p><strong>Note</strong>. There is no such type as a <code>String</code>-object type. Remember, there are only 7 types in JavaScript, the primitives and object. Object does not have subtypes and so String-object is not really a type. The <code>String</code> constructor creates a new object, that&apos;s it. The object it creates so happens (not by chance, as we will see) to contain properties and methods useful for working with strings. I will continue using the <code>Constructor</code>-object type terminology as shorthand for referring to an-object-with-properties-and-methods-related-to-the-Constructor.    </p>
<p><strong>Note</strong>. It is common to capitalize the first letter of a constructor. Therefore, <code>String</code> refers to a constructor while <code>string</code> refers to the primitive type.</p>
</blockquote>
<pre><code class="lang-js"><span class="hljs-comment">// string literal</span>
<span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;Derek&quot;</span>;

<span class="hljs-comment">// String object</span>
<span class="hljs-keyword">var</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;Derek&quot;</span>);

<span class="hljs-comment">// str1 is, in fact, a string</span>
<span class="hljs-built_in">console</span>.log(str1); 
<span class="hljs-comment">// =&gt; &quot;Derek&quot;</span>

<span class="hljs-comment">// str2 is not a string.</span>
<span class="hljs-comment">// Instead it is an object that wraps the original string value.</span>
<span class="hljs-built_in">console</span>.log(str2); 
<span class="hljs-comment">// =&gt; something like String {&quot;Derek&quot;} or [String, &quot;Derek&quot;] depending on browser</span>

<span class="hljs-comment">// valueOf will return the literal value wrapped by the object type</span>
<span class="hljs-built_in">console</span>.log(str2.valueOf()); <span class="hljs-comment">// =&gt; &quot;Derek&quot;</span>

<span class="hljs-comment">// The two types are not the same</span>
str1 === str2 <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-comment">// but the values are.</span>
str1 === str2.valueOf() <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-keyword">typeof</span> str1; <span class="hljs-comment">// =&gt; &apos;string&apos;</span>
<span class="hljs-keyword">typeof</span> str2; <span class="hljs-comment">// =&gt; &apos;object&apos;</span>
</code></pre>
<blockquote>
<p><strong>Tip</strong>. The <code>typeof</code> operator will return the type of the supplied argument as a string, e.g., <code>typeof str1 // =&gt; &apos;string&apos;</code>. <code>typeof</code> is an operator and may be used without <code>()</code>, much like math operators (<code>+</code>, <code>*</code>, <code>-</code>, etc.).</p>
</blockquote>
<p>In JavaScript land, primitives are automatically converted to corresponding object types, providing properties and methods related to that type. This auto-conversion is what allows for such madness as <code>&quot;hello world&quot;.toUpperCase()</code>, a primitive accessing a method using dot notation.</p>
<p>In the introductory paragraph for this section I was careful to state that all data types, except <code>null</code> and <code>undefined</code>, <strong>act</strong> as objects, as opposed to saying all data types <strong>are</strong> objects. This distinction, though accurate, is not too important at this time. The important takeaway is that all data types, except <code>null</code> and <code>undefined</code>, act as objects. This is to say that all data types support dot notation for accessing additional properties and methods. Even so called primitives act as objects and support dot notation. Just remember, <code>null</code> and <code>undefined</code> are special.</p>
<h3 id="literals"><a name="literals" class="plugin-anchor" href="#literals"><i class="fa fa-link" aria-hidden="true"></i></a>Literals</h3>
<p>To define a value without using a constructor function is to create a literal value of that type. For example, string literals can be created using single or double quotes. Both primitives and object types can be declared as literals.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Primitives declared as literals</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Derek&quot;</span>;
<span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;
<span class="hljs-keyword">var</span> something = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">var</span> nothing = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> isOldEnough = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// object literals</span>
<span class="hljs-keyword">var</span> myObj = {
    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Derek&quot;</span>
}
<span class="hljs-keyword">var</span> myList = [<span class="hljs-string">&quot;Derek&quot;</span>, <span class="hljs-string">&quot;Kris&quot;</span>, <span class="hljs-number">100</span>];
</code></pre>
<p>As shown with <code>String</code>, objects may also be created with constructors. </p>
<pre><code class="lang-js"><span class="hljs-comment">// Using constructor functions</span>
<span class="hljs-comment">// Primitives</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;Derek&quot;</span>);
<span class="hljs-keyword">var</span> age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">28</span>);
<span class="hljs-keyword">var</span> isOldEnough = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>); 

<span class="hljs-comment">/* null and undefined do not act as objects
and do not have constructors to create object equivalents. 
*/</span>

<span class="hljs-comment">// objects and array constructors</span>
<span class="hljs-keyword">var</span> myObh = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>({
    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Derek&quot;</span>
});
<span class="hljs-keyword">var</span> myList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&quot;Derek&quot;</span>, <span class="hljs-string">&quot;Kris&quot;</span>, <span class="hljs-number">100</span>);
</code></pre>
<p>In practice, constructors are rarely used, if ever, to create primitive types, plain objects or arrays. Values of these types are almost always declared as literals. Constructors tend to be used to <strong>instantiate</strong> custom object types. This will be explored later on.</p>
<blockquote>
<p><strong>Instantiate</strong> To create an instance of an Object type. <code>new String(&quot;Hello&quot;)</code> is creating, or instantiating, a new instance of the <code>String</code> type with a value of <code>&quot;Hello&quot;</code>. </p>
</blockquote>
<h3 id="comparing-values"><a name="comparing-values" class="plugin-anchor" href="#comparing-values"><i class="fa fa-link" aria-hidden="true"></i></a>Comparing Values</h3>
<p>JavaScript provides multiple ways to check for equality or inequality between values.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;Derek&quot;</span>;
<span class="hljs-keyword">var</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;Derek&quot;</span>);

<span class="hljs-comment">// == for comparing values</span>
str1 == str2 <span class="hljs-comment">// =&gt; true</span>

<span class="hljs-comment">// === for comparing values and types</span>
str1 === str2 <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// != for contrasting values</span>
str1 != str2 <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-comment">// !== for contrasting values and types</span>
str1 !== str2 <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<ul>
<li><code>==</code> checks that that the operands (both sides of the comparison) are equal in value without comparing types. JavaScript will coerce (convert) the values to the same type before comparing. For this reason, <code>str1 == str2</code> returns <code>true</code> as both contain the value of <code>&quot;Derek&quot;</code> but note that <code>str1</code> and <code>str2</code> are not of the same type. The former is a <code>string</code> literal while the latter is a <code>String</code>-object.</li>
<li><code>!=</code> Checks that the operands are not equal in value without checking types. For this reason, <code>str1 != str2</code> returns <code>false</code> as the operands are equal in value when coerced to the same type.</li>
<li><code>===</code> checks that both operands are equal in value <strong>and</strong> are of the same type. Therefore <code>str1 === str2</code> returns <code>false</code> because the operands are not of the same type.</li>
<li><code>!==</code> checks that the operands are either not equal in value or not of the same type. <code>str1 !== str2</code> returns <code>true</code> since the operands vary in type.</li>
</ul>
<p>JavaScript <del>can</del> will do some strange things when coercing a value from one type to another. For this reason, it is recommended that <code>===</code> and <code>!==</code> are used to compare operands by type and value to avoid unexpected results from type coercion.</p>
<p>Here is a more realistic example of JavaScript coercing a value from one type to another that may pop up in practice.</p>
<pre><code class="lang-js"><span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-string">&quot;1&quot;</span> === <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-string">&quot;true&quot;</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-string">&quot;true&quot;</span> === <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; false</span>

<span class="hljs-string">&quot;1&quot;</span> != <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-string">&quot;1&quot;</span> !== <span class="hljs-number">1</span> <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-string">&quot;true&quot;</span> != <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; false</span>
<span class="hljs-string">&quot;true&quot;</span> !== <span class="hljs-literal">true</span> <span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>Again, use <code>===</code> and <code>!==</code>.</p>
<h2 id="variable-scope"><a name="variable-scope" class="plugin-anchor" href="#variable-scope"><i class="fa fa-link" aria-hidden="true"></i></a>Variable Scope</h2>
<hr>
<p>&quot;There is no scope but function scope&quot;. This use to be a popular statement when talking about JS. The meaning is simple, variables defined outside of any function are global while variables defined within a function are local to that function and cannot be accessed by the outside world. This statement, though true for variables declared with <code>var</code>, is not true for values created with <code>let</code> and <code>const</code>. For now, lets examine function-scoped variables declared with <code>var</code>.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Global variable</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">127</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAge</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// this age variable is local to logAge</span>
    <span class="hljs-comment">// and overrides the global age variable, within logAge,</span>
    <span class="hljs-comment">// since they share the same name</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">23</span>;
    <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 23</span>
}

<span class="hljs-comment">// The age variable local to logAge</span>
<span class="hljs-comment">// had no impact on the global age variable</span>
<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 127</span>
<span class="hljs-comment">// Global variables are also accessible from the window object. </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.age);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// name is local to printName</span>
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Derek&quot;</span>;
    <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// =&gt; Derek</span>
}

<span class="hljs-comment">// There is no global name variable</span>
<span class="hljs-comment">// and the name variable within printName</span>
<span class="hljs-comment">// is no longer in scope and thus not accessible</span>
<span class="hljs-built_in">console</span>.log(name);
<span class="hljs-comment">// uncaught referenceError. name is not defined.</span>
</code></pre>
<p>Here is another example showing that once again &quot;there is no scope but function scope&quot;, at least when it comes to <code>var</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Still a global variable </span>
    <span class="hljs-comment">// and accessible from outside the conditional block</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">25</span>;
}
<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 25</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAge</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// still local to logAge</span>
        <span class="hljs-comment">// and accessible to the rest of logAge</span>
        <span class="hljs-keyword">var</span> age = <span class="hljs-number">35</span>;
    }
    <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 35</span>
}
</code></pre>
<p>Global variables, once defined, are accessible from anywhere using the global object, <code>window</code>, even from other files, hence global.</p>
<h3 id="block-scope"><a name="block-scope" class="plugin-anchor" href="#block-scope"><i class="fa fa-link" aria-hidden="true"></i></a>Block Scope</h3>
<p>Unlike <code>var</code>, <code>let</code> and <code>const</code> declare block-scoped values. Values that are scoped to a single block of code (code between a matching pair of <code>{</code> and <code>}</code>).</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logAgeWithLet</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// age is scoped to the surrounding conditional block, </span>
        <span class="hljs-comment">// instead of the surrounding function, </span>
        <span class="hljs-comment">// and is thus not accessible outside the conditional block</span>
        <span class="hljs-keyword">let</span> age = <span class="hljs-number">28</span>;
        <span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// =&gt; 28</span>
    }
    <span class="hljs-built_in">console</span>.log(age);
    <span class="hljs-comment">// Uncaught ReferenceError: age is not defined.</span>
}
</code></pre>
<p>Though still valid for variables created with <code>var</code>, &quot;there is no scope but function scope&quot; does not apply to values created with <code>let</code> and <code>const</code>, as shown above.</p>
<h3 id="hoisting"><a name="hoisting" class="plugin-anchor" href="#hoisting"><i class="fa fa-link" aria-hidden="true"></i></a>Hoisting</h3>
<p>What happens when one tries to access a variable that has not been defined? Let&apos;s find out.</p>
<pre><code class="lang-js"><span class="hljs-built_in">console</span>.log(someVariable);
<span class="hljs-comment">// =&gt; Uncaught ReferenceError: someVariable is not defined</span>
</code></pre>
<p>As opposed to accessing a variable that has been declared but not initialized.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> age;
<span class="hljs-built_in">console</span>.log(age);
<span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>Since the following code accesses <code>age</code> before it is declared, one might expect a &quot;not defined&quot; reference error.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(age);
    <span class="hljs-comment">// expect an uncaught ReferenceError.</span>

    <span class="hljs-keyword">var</span> age = <span class="hljs-number">28</span>;
}

doSomething();
<span class="hljs-comment">// =&gt; undefined</span>
</code></pre>
<p>In reality, it results in an <code>undefined</code> instead of a reference error. That is because the above code is evaluated as the following when interpreted by the JavaScript runtime environment. </p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// the age declaration is hoisted to the top of the defining function scope</span>
    <span class="hljs-keyword">var</span> age;
    <span class="hljs-built_in">console</span>.log(age);

    <span class="hljs-comment">// age is still initialized in the same location</span>
    age = <span class="hljs-number">28</span>;
}
</code></pre>
<p>The interpreter lifts all variable declarations to the top of the defining scope. This is known as hoisting. Recall, &quot;there is no scope but function scope&quot;, so hoisting lifts variable declarations to the top of the surrounding function declaration, as demonstrated above. Note that initializations are not hoisted and occur in the original location, as shown above.</p>
<blockquote>
<p><strong>Hoisting</strong> <del>to lift heavy objects up high.</del> is process performed by the interpreter in which all variable declarations are evaluated prior to code execution. </p>
</blockquote>
<p><code>let</code> and <code>const</code> are not hoisted (too heavy). The following code will result in a &quot;not defined&quot; reference error.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(age);
    <span class="hljs-comment">// =&gt; Uncaught ReferenceError: age is not defined</span>

    <span class="hljs-keyword">let</span> age = <span class="hljs-number">28</span>;
}
</code></pre>
<h2 id="modules"><a name="modules" class="plugin-anchor" href="#modules"><i class="fa fa-link" aria-hidden="true"></i></a>Modules</h2>
<hr>
<p>Since variables declared outside of any function are global, it is common to wrap all code within a function declaration in order to avoid polluting the global namespace. This is known as the module pattern and is a common design pattern for JavaScript libraries, including the popular jQuery library.</p>
<pre><code class="lang-js"><span class="hljs-comment">// Self-invoking anonymous function.</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// age scoped to the surrounding function, thus not polluting the </span>
    <span class="hljs-comment">// global namespace.</span>
    <span class="hljs-comment">// age is only accessible from within the defining anonymous function, aka module,</span>
    <span class="hljs-comment">// thus age is said to be private to this module.</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// some code</span>

        <span class="hljs-comment">// doSomething has access to the surrounding scope and thus has access to age.</span>
        <span class="hljs-built_in">console</span>.log(age);
    }

    <span class="hljs-comment">// This module does not return any properties or functions</span>
    <span class="hljs-comment">// for consumers of the library to work with.</span>
    <span class="hljs-comment">// Instead, the module executes doSomething as soon as </span>
    <span class="hljs-comment">// it is loaded.</span>
    doSomething();
})();
</code></pre>
<pre><code class="lang-js"><span class="hljs-comment">// self-invoking anonymous function</span>
<span class="hljs-keyword">var</span> libraryGlobal = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Private to this module</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// do something</span>

        <span class="hljs-built_in">console</span>.log(age);
    }

    <span class="hljs-comment">// This module returns functionality for consumers</span>
    <span class="hljs-comment">// to interact with.</span>
    <span class="hljs-comment">// return doSomething to be executed at a later time.</span>
    <span class="hljs-keyword">return</span> {
        doSomething: doSomething
    };
})();

<span class="hljs-comment">// Using the library elsewhere</span>
libraryGlobal.doSomething();
</code></pre>
<p>Both examples demonstrate the module pattern. The first executes functionality, <code>doSomething</code>, when loaded while the second example exposes the same functionality, which is stored in the <code>libraryGlobal</code> variable, to be executed at a later time.</p>
<p>Both examples make use of self-invoking (or self-executing) anonymous functions to encapsulate functionality and, if necessary, expose properties and methods off a single global variable (the second example).</p>
<blockquote>
<p><strong>Anonymous functions</strong> are unnamed functions, e.g., <code>function() { ... }</code>, as opposed to <code>function sayHello() { ... }</code> which is a named function.</p>
<p><strong>Self-invoking functions</strong> are functions that execute immediately after being defined. This can be achieved by wrapping the function definition in <code>()</code> followed by an additional <code>()</code> to call the function, e.g., <code>(function sayHello() { ... })();</code>. Note that both named and anonymous functions can be self-invoking.</p>
</blockquote>
<h2 id="closures"><a name="closures" class="plugin-anchor" href="#closures"><i class="fa fa-link" aria-hidden="true"></i></a>Closures</h2>
<hr>
<blockquote>
<p>A <strong>closure</strong> is a function bounded to the environment, or scope, in which it was declared. </p>
</blockquote>
<p>Closures are created when a function returns another function. Simply stated, a closure is when a function creates scope for another function to use at a later time. </p>
<pre><code class="lang-js"><span class="hljs-comment">// 1. First function creating scope...</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAgeRestriction</span>(<span class="hljs-params">minimumAgeLimit</span>) </span>{

    <span class="hljs-keyword">var</span> restrictedMessage = <span class="hljs-string">&quot;does not meet the age requirement&quot;</span>;

    <span class="hljs-comment">// 2. ...to be used by another function at a later time.</span>
    <span class="hljs-comment">// checkAgeRestriction will always have access to minimumAgeLimit</span>
    <span class="hljs-comment">// and restrictedMessage defined in the surrounding scope </span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAgeRestriction</span>(<span class="hljs-params">age</span>) </span>{
        <span class="hljs-keyword">if</span>(age &gt; minimumAgeLimit) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;you may enter&apos;</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(age + <span class="hljs-string">&quot; &quot;</span> + restrictedMessage);
        }
    }

    <span class="hljs-comment">// return checAgeRestriction which is bounded to the defining scope</span>
    <span class="hljs-comment">// where minimumAgeLimit and restricedMessage are defined.</span>
    <span class="hljs-keyword">return</span> checkAgeRestriction;
}

<span class="hljs-comment">// canDrink is a clusure</span>
<span class="hljs-keyword">var</span> canDrink = setAgeRestriction(<span class="hljs-number">21</span>);

<span class="hljs-comment">// canDrink will have access to the </span>
<span class="hljs-comment">// minimumAgeLimit, which is set to 21,</span>
<span class="hljs-comment">// and the restrictedMessage</span>
<span class="hljs-comment">// for as long as it needs it and can be called </span>
<span class="hljs-comment">// many times with different ages to compare </span>
<span class="hljs-comment">// against the minimumAgeLmit</span>
canDrink(<span class="hljs-number">44</span>); <span class="hljs-comment">// =&gt; &quot;you may enter&quot;</span>

<span class="hljs-comment">// much later on...</span>
canDrink(<span class="hljs-number">19</span>); <span class="hljs-comment">// =&gt; &quot;19 does not meet the age requirement&quot;</span>
</code></pre>
<p>Recall that &quot;there is no scope but function scope&quot;. With that in mind, it makes sense that it is functions that create closures as it is functions that create scope.  </p>
<blockquote>
<p><strong>Note</strong>. <code>libraryGlobal.doSomething</code> shown in the modules section is an example of a closure as it is a function that is bound to it&apos;s defining scope and has access to the variables defined in that scope, such as <code>age</code>.</p>
</blockquote>
<h2 id="this"><a name="this" class="plugin-anchor" href="#this"><i class="fa fa-link" aria-hidden="true"></i></a>This</h2>
<hr>
<blockquote>
<p>In JavaScript, <strong><code>this</code></strong> is a special keyword that refers to an object, specifically the calling object of the current execution. </p>
</blockquote>
<p>For example</p>
<pre><code class="lang-js"><span class="hljs-comment">// global variable accessible off the window object.</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;

<span class="hljs-keyword">var</span> person = {
    age: <span class="hljs-number">20</span>,
    getAge: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// this refers to the calling object</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age);
    }
}

<span class="hljs-comment">// person calls getAge using dot notation.</span>
<span class="hljs-comment">// person is the calling object.</span>
person.getAge();
<span class="hljs-comment">// =&gt; 20</span>
</code></pre>
<p>The above prints <code>20</code>, as one might expect. Now let&apos;s change the calling object and see what happens.</p>
<pre><code class="lang-js"><span class="hljs-comment">// handler to getAge function is stored in newGetAge.</span>
<span class="hljs-keyword">var</span> newGetAge = person.getAge;

<span class="hljs-comment">// What object is calling newGateAge?</span>
<span class="hljs-comment">// turns out, the global object, window. </span>
<span class="hljs-comment">// this is equivalent to writing window.newGetAge(), which</span>
<span class="hljs-comment">// clarifies that it is the window object calling newGetAge</span>
newGetAge();
<span class="hljs-comment">// =&gt; 10.</span>
</code></pre>
<p>In this example, the <code>getAge</code> function handler is stored in the <code>newGetAge</code> global variable. When a function is called directly (without dot notation) it is invoked by the global object, <code>window</code>. <code>newGetAge</code> is called by <code>window</code> and outputs <code>10</code> to the browser console since <code>window.age = 10</code>, as declared in the first code snippet. </p>
<p><code>this</code> causes all sorts of bugs, unexpected outcomes, nightmares, confusion and headaches when functions are called from unexpected calling contexts. Calling a function from an unkown object may sound farfetched but its not, it happens all the time. More on that later.</p>
<h3 id="bind"><a name="bind" class="plugin-anchor" href="#bind"><i class="fa fa-link" aria-hidden="true"></i></a>Bind</h3>
<p><strong>bind</strong> is a method available to functions that will return a new copy of the original function that behaves identically to the original function with one exception. The <code>this</code> object will be bounded to a provided object for all future calls, regardless of how that the new function is called.</p>
<pre><code class="lang-js"><span class="hljs-comment">// global variable accessible off the window object.</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>; 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">globalGetAge</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age);
}

<span class="hljs-keyword">var</span> person = {
    age: <span class="hljs-number">20</span>
};

<span class="hljs-comment">// this time, declare person.getAage as a bounded</span>
<span class="hljs-comment">// version of globalGetAage in which this will always be bounded </span>
<span class="hljs-comment">// to person</span>
person.getAge = globalGetAge.bind(person);

<span class="hljs-comment">// still prints 20, as expected</span>
person.getAge(); <span class="hljs-comment">// =&gt; 20;</span>

<span class="hljs-keyword">var</span> newGetAge = person.getAge;

<span class="hljs-comment">// window is the caling object.</span>
<span class="hljs-comment">// but person.getAge was bounded to person so </span>
<span class="hljs-comment">// this = person so this.age = person.age = 20.</span>
newGetAge(); 
<span class="hljs-comment">// =&gt; 20</span>
</code></pre>
<blockquote>
<p><strong>Note</strong>. <code>bind</code> returns a new copy of the original function. In the above example, globalGetAge was not modified. Only <code>person.getAge</code> is bounded.</p>
</blockquote>
<p><code>bind</code>ing a function to a specific calling object (<code>this</code>) makes it behave in a more predictable way and combats issues caused from calling functions from different calling contexts. </p>
<p><code>bind</code> is a variadic function. A fancy wasy of saying that <code>bind</code> accepts an unlimitied number of arguments. The first accepted argument is the object that will bind to <code>this</code> in the original function. The remaining arguments will bind to the parameter list of the original function. The returned function will accept the remaining, if any, arguments that were not bounded.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> greetingConfig = {
    greeting: <span class="hljs-string">&quot;Hello&quot;</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayGreeting</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
    <span class="hljs-built_in">console</span>.log(greeting + <span class="hljs-string">&quot; &quot;</span> + firstname + <span class="hljs-string">&quot; &quot;</span>  + lastName);
}

<span class="hljs-comment">// binding greetingConfig to this and Derek to firstname</span>
<span class="hljs-keyword">var</span> boundedGreeting = sayGreeting.bind(greetingConfig, <span class="hljs-string">&quot;Derek&quot;</span>);

<span class="hljs-comment">// The firstName argument has been bounded so only</span>
<span class="hljs-comment">// the lastName parameter needs to be provided</span>
boundedGreeting(<span class="hljs-string">&quot;Worthen&quot;</span>);
<span class="hljs-comment">// =&gt; &quot;Hello Derek Worthen&quot;</span>
</code></pre>
<blockquote>
<p><strong>Variadic function</strong>: a function that has indefinite arity.</p>
<p><strong>Arity</strong>: the number of arguments a function accepts. </p>
<p><strong>Note</strong>. Ignore the above definitions. Nobody, but the truest of nerds, uses the above terms. </p>
</blockquote>
<p>Once bounded, a function cannot be rebounded.</p>
<pre><code class="lang-js"><span class="hljs-comment">// person.getAge is already bounded.</span>
<span class="hljs-comment">// this will not work</span>
<span class="hljs-keyword">var</span> rebindPersonGetAgeToWindow = person.getAge.bind(<span class="hljs-built_in">window</span>);

rebindPersonGetAgeToWindow();
<span class="hljs-comment">// still prints 20 as the function is still bounded to person, not window.</span>
</code></pre>
<!-- ## Prototype and Inheritance

---

Earlier I stated that I will use `Constructor`-object terminology to refer to an-object-with-properties-related-to-the-constructor. So `String`-object refers to the fact that the `String` constructor creates an object that contains properties and methods for working with strings. But where do these properties and methods come from? Where does `toUpperCase` come from?

Inheritance, of course.  -->

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="introduction.html" class="navigation navigation-prev " aria-label="Previous page: Introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="./" class="navigation navigation-next " aria-label="Next page: Getting Started">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Primer","level":"1.2","depth":1,"next":{"title":"Getting Started","level":"1.3","depth":1,"path":"README.md","ref":"README.md","articles":[{"title":"Environment","level":"1.3.1","depth":2,"path":"environment.md","ref":"environment.md","articles":[]},{"title":"Project Structure","level":"1.3.2","depth":2,"path":"project-structure.md","ref":"project-structure.md","articles":[]},{"title":"Build","level":"1.3.3","depth":2,"path":"build.md","ref":"build.md","articles":[]},{"title":"Hello World","level":"1.3.4","depth":2,"path":"hello-world.md","ref":"hello-world.md","articles":[]}]},"previous":{"title":"Introduction","level":"1.1","depth":1,"path":"introduction.md","ref":"introduction.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["anchors"],"pluginsConfig":{"anchors":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"primer.md","mtime":"2018-03-03T17:58:25.329Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-03-03T17:59:03.842Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

